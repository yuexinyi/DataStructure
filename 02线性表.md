# 02线性表

# 2.1线性表基础

## 2.1.1常见的数据结构

分为线性结构和非线性结构，线性结构典型代表是线性表，非线性结构典型代表是树和图

## 2.1.2线性表叙述

是由n个数据元素组成的有限序列。线性序列每个元素必须具有相同的结构。

## 2.1.3线性表的分类

从数据在物理内存存储形式来看，线性表可分为：顺序表和链式表

# 2.2顺序表

## 2.2.1顺序表叙述

顺序表：用一组地址连续的存储单元依次存放线性表的元素

## 2.2.2顺序表代码实现

接口声明：

```java
public interface Sequence {
	void add(Object data);
	Object remove(int index);
	Object set(int index,Object newData);
	Object get(int index);
	boolean contains(Object data);
	int size();
	Object[] toArray();
	void clear();
}
```

基于数组实现的线性表：

```java
import java.util.Arrays;

public class SequenceArrayImpl implements Sequence {
private static final int DEFAULT_CAPACITY = 10;
private int size;
private Object[] elementData;
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
public SequenceArrayImpl() {
this.elementData = new Object[DEFAULT_CAPACITY];
}
@Override
public void add(Object data) {
ensureCapacity(size+1);
elementData[size++] = data;
}
@Override
public Object remove(int index) {
rangCheck(index);
Object oldData = elementData[index];
int moveSize = size - index - 1;
if (moveSize > 0) {
System.arraycopy(elementData,index+1,elementData,index,moveSize);
}
elementData[--size] = null;
return oldData;
}
@Override
public Object set(int index, Object newData) {
rangCheck(index);
Object oldData = elementData[index];
elementData[index] = newData;
return oldData;
}
@Override
public Object get(int index) {
rangCheck(index);
return elementData[index];
}
 @Override
public boolean contains(Object data) {
if (data == null) {
for (int i = 0;i < size;i++) {
if (elementData[i] == null) {
return true;
}
}
}else {
for (int i = 0;i < size;i++) {
if (elementData[i].equals(data)) {
return true;
}
}
}
return false;
}
@Override
public int size() {
return this.size;
}
@Override
public Object[] toArray() {
return Arrays.copyOf(elementData,size);
}
@Override
public void clear() {
for (int i = 0;i < size;i++) {
elementData[i] = null;
}
this.size = 0;
}
private void ensureCapacity(int minCap) {
// oversize
if (minCap - elementData.length > 0) {
grow(minCap);
}
}
private void grow(int minCap) {
int oldCap = elementData.length;
int newCap = oldCap << 1;
if (newCap - minCap < 0) {
newCap = minCap;
}
if (newCap - MAX_ARRAY_SIZE > 0) {

throw new ArrayIndexOutOfBoundsException("超过数组最⼤大阈值");
}
elementData = Arrays.copyOf(elementData,newCap);
}
private void rangCheck(int index) {
if (index >= size) {
throw new IndexOutOfBoundsException("下标不不存在!");
}
}
}
```

